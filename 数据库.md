## 1、数据库三大范式 ##

数据库三大范式是一组设计数据库的原则，目的是减少冗余，提高数据存储的效率和数据异质性

**第一范式1NF**：遵循原子性。即，**表中字段的数据，不可以再拆分**。

比如字段 `userInfo`: `广东省 10086'` ，依照第一范式必须拆分成 `userInfo`: `广东省` `userTel`:` 10086`两个字段。



**第二范式2NF**：在满足第一范式的情况下，遵循唯一性，消除部分依赖。即，**表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。**（**一个表只能描述一件事情**）。

  举个例子。假定选课关系表为`student_course`(student_no, student_name, age, course_name, grade, credit)，主键为(student_no, course_name)。其中学分完全依赖于课程名称，姓名年龄完全依赖学号，不符合第二范式，会导致数据冗余（学生选n门课，姓名年龄有n条记录）、插入异常（插入一门新课，因为没有学号，无法保存新课记录）等问题。

最好分成三张表，一张学生表（学号为主键），一张课程表（课程名称为主键），一张成绩表（学号课程名称的联合主键）



**第三范式3NF**：在满足第二范式的情况下，消除传递依赖。即，**在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B**。

![1701758979408](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\1701758979408.png)

## 2、说说主键、外键、超键、候选键的差别并举例 ##

- ![1701759269639](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\1701759269639.png)

**主键(primary key):**用于唯一标识关系表中每一行数据的字段或字段组合，确保表中每一行数据都能被唯一的标识和访问，常见的主键选择时使用自增长的整数或具有唯一性 的字段

**外键(foreign key)：**用于建立表与表关系的字段，外键一般时另外一个表的主键，从而在表之间创建关系。

## 3、为什么一般用自增列作为主键？

- 如果表使用自增主键，那么每次插入新的记录，记录就会**顺序添加**到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。
- 如果使用非自增主键（如果身份证号或学号等），由于每次**插入主键的值近似于随机**，因此每次新记录都要被插到现有索引页的中间某个位置，此时MySQL**不得不为了将新记录插到合适位置而移动数据**，这**增加了很多开销，同时会增加大量的碎片**。

## 4、存储过程

存储过程是一个**预编译的SQL语句**，优点是允许模块化的设计，就是说**只需创建一次，以后在该程序中就可以调用多次。**

**创建存储过程：**

```mysql
CREATE PROCEDURE procedure_name (parameter_list)
BEGIN
    -- SQL statements
END 
```

**执行存储过程：**

```mysql
CALL procedure_name(parameters);
```

**删除存储过程：**

```mysql
DROP PROCEDURE IF EXISTS procedure_name;
```

优点：

- 存储过程是预编译过的，执行效率高。
- 存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。
- 安全性高，执行存储过程需要有一定权限的用户。
- 存储过程可以重复使用，可减少工作量冗余。

缺点：移植性差

与函数的区别:

- 存储过程用户在数据库中**完成特定操作或者任务**（如插入，删除等），函数用于**返回特定的数据**。
- 存储过程声明用procedure，函数用function。
- 存储过程不需要返回类型，函数必须要返回类型。
- 存储过程可作为独立的pl-sql执行，函数不能作为独立的plsql执行，必须作为表达式的一部分。
- 存储过程只能通过out和in/out来返回值，函数除了可以使用out，in/out以外，还可以使用return返回值。
- sql语句（DML或SELECT)中不可用调用存储过程，而函数可以。

## 5、视图

视图：在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。您可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，也可以呈现数据，就像这些数据来自于某个单一的表一样。

优点：

- 对数据库的访问，因为**视图可以有选择性的选取数据库里的一部分**。
- 用户通过简单的查询可以从复杂查询中得到结果。
- 维护数据的独立性，试图可从多个表检索数据。
- 对于相同的数据可产生不同的视图。

缺点：

**查询视图时，必须把视图的查询转化成对基本表的查询**，如果这个视图是由一个复杂的多表查询所定义，那么就无法更改数据。**注释：**视图总是显示最新的数据！每当用户查询视图时，数据库引擎通过使用视图的 SQL 语句重建数据。

**SQL CREATE VIEW 语法**

```mysql
CREATE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition
```

## 6、索引

### （1）概念

索引是存储引擎用于提高数据库表的访问速度的一种**数据结构**。它可以比作一本字典的目录，可以帮你快速找到对应的记录。索引一般存储在磁盘的文件中，它是占用物理空间的。

### （2）优缺点

优点：

- **加快数据查找的速度**
- 为用来排序或者是分组的字段添加索引，可以**加快分组和排序的速度**
- 加快表与表之间的连接

缺点：

- 建立索引需要**占用物理空间**
- **会降低表的增删改的效率**，因为每次对表记录进行增删改，需要进行**动态维护索引**，导致增删改时间变长

### （3）建立索引的情况

**什么情况下需要建索引？**

1. 经常**用于查询的字段**
2. 经常**用于连接的字段**建立索引，可以加快连接的速度
3. 经常**需要排序的字段**建立索引，因为**索引已经排好序，可以加快排序查询速度**

**什么情况下不建索引？**

1. `where`条件中用不到的字段不适合建立索引（不用于查询的字段）
2. **表记录较少**。比如只有几百条数据，没必要加索引。
3. **需要经常增删改**。需要评估是否适合加索引
4. **参与列计算**的列不适合建索引
5. **区分度不高**的字段不适合建立索引，如性别，只有男/女/未知三个值。加了索引，查询效率也不会提高。

**SQL CREATE INDEX 语法**

```mysql
CREATE INDEX index_name
ON table_name (column_name)
```

**DROP INDEX 语句**(用于 MySQL 的 DROP INDEX 语法：)

```mysql
ALTER TABLE table_name DROP INDEX index_name
```

### （4）索引的数据结构

索引的数据结构主要有B+树和哈希表，对应的索引分别为B+树索引和哈希索引。**InnoDB引擎的索引类型有B+树索引和哈希索引，默认的索引类型为B+树索引。**

#### 1.B+树

- B+ 树是基于B 树和叶子节点顺序访问指针进行实现，它具有B树的平衡性，并且通过顺序访问指针来提高区间查询的性能。
- 在 B+ 树中，节点中的 `key` 从左到右递增排列，如果某个指针的左右相邻 `key` 分别是 keyi 和 keyi+1，则该指针指向节点的所有 `key` 大于等于 keyi 且小于等于 keyi+1。
- 进行查找操作时，首先在根节点进行**二分查找**，找到`key`所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出`key`所对应的数据项。



![img](http://img.topjavaer.cn/img/B+%E6%A0%91%E7%B4%A2%E5%BC%950.png)

MySQL 数据库使用最多的索引类型是`BTREE`索引，底层基于B+树数据结构来实现。

#### **2.哈希表**

**2.1.概念**

- 希表**也叫散列表，是基于**哈希函数和数组**的一种数据结构
- **哈希函数**帮我们把非int的**「键」**或者**「关键字」**转化成int，可以用来做数组的下标。实际就是**将键**用哈希函数映射成数组下标，然后将数据存到数组对应下标的位置里去。
- 但不同键值函数映射出的数组下标可以相同，这就是**哈希冲突**。
- 解决哈希冲突的两种方法：**开放地址法**，**链表法**
- 在开放地址法中，若数据不能直接存放在哈希函数计算出来的数组下标时，就需要寻找其他位置来存放。在开放地址法中有三种方式来寻找其他的位置，分别是**「线性探测」**、**「二次探测」**、**「再哈希法」**

**2.2.解决哈希冲突的改进**

- **线性探测—容易发生数据聚集**

插入：找冲突位置的空白单元，后移到没数据的地方就落下。

查找过程：从冲突位置找，一个个比对数据的值是不是相等，直到找到相同数据值为止。在查找过程中，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定哈希表中不存在这个数据。

删除：不能简单的把这一项数据删除，让它变成空，因为这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。？因此我们**需要一个特殊的数据来顶替这个被删除的数据**，因为我们的学生学号都是正数，所以我们用学号等于`-1`来代表被删除的数据。	

- **二次探测**—二次聚集

把冲突放到相隔较远的单元，而不是和原始位置相邻的单元。

在线性探测中，如果哈希函数得到的原始下标是x,线性探测就是x+1,x+2,x+3......，以此类推，而在二次探测中，探测过程是x+1,x+4,x+9,x+16,x+25......

- **双哈希**

双哈希是除了第一个哈希函数外再增加一个哈希函数用来根据关键字**生成探测步长**

第一个哈希函数生成初始下标，第二个哈希函数生成从初始下标开始的移动步长

- **链表法**

开放地址法中，通过在哈希表中再寻找一个空位解决冲突的问题，还有一种更加常用的办法是使用**「链表法」**来解决哈希冲突。**「链表法」**相对简单很多，**「链表法」**是每个数组对应一条链表。当某项关键字通过哈希后落到哈希表中的某个位置，把该条数据添加到链表中，其他同样映射到这个位置的数据项也只需要添加到链表中，并不需要在原始数组中寻找空位来存储。

![1701764015346](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\1701764015346.png)

**2.3.哈希索引**

 哈希索引是基于哈希表实现的，对于每一行数据，存储引擎会对索引列进行哈希计算得到哈希码，并且哈希算法要尽量保证不同的列值计算出的哈希码值是不同的，将哈希码的值作为哈希表的key值，将指向数据行的指针作为哈希表的value值。这样查找一个数据的时间复杂度就是O(1)，一般多用于精确查找。

### （5）Hash索引和B+树索引的区别？

- 哈希索引**不支持排序**，因为哈希表是无序的。
- 哈希索引**不支持范围查找**。
- 哈希索引**不支持模糊查询**及多列索引的最左前缀匹配。
- 因为哈希表中会**存在哈希冲突**，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点。

### （6）为什么B+树比B树更适合实现数据库索引？

- B+树的数据都存储在叶子结点中，非叶子节点均为索引，更适合范围查询
- B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。**减少更多的I/O支出**。
- B+树的**查询效率更加稳定**，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。B树查询路径差异大，可能很快就结束查询，也可能很慢。

### （7）MySQL聚簇索引和非聚簇索引的区别

数据库表的索引从数据存储方式上可以分为聚簇索引和非聚簇索引两种。“聚簇”的意思是数据行被按照一定顺序一个个紧密地排列在一起存储。我们熟悉的InnoDB和MyISAM两大引擎，InnoDB的默认数据结构是聚簇索引，而MyISAM是非聚簇索引。

**聚簇索引**

聚簇索引（Clustered Index）并不是一种单独的索引类型，而是一种数据存储方式。当表有了聚簇索引的时候，表的数据行都存放在索引树的叶子页中。无法把数据行放到两个不同的地方，所以一张表只允许有一个聚簇索引。

InnoDB的聚簇索引实际上是将索引和数据保存中同一个B-Tree中。InnoDB通过主键聚集数据，如果没有定义主键，InnoDB会选择一个唯一的的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。

**非聚簇索引**

非聚簇索引（NoClustered Index），又叫二级索引。二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值。当通过二级索引查找行，**存储引擎需要在二级索引中找到相应的叶子节点，获得行的主键值，然后使用主键去聚簇索引中查找数据行，这需要两次B-Tree查找。**

聚簇索引和非聚簇索引的存储方式区别：

- 存储：在MyISAM引擎索引和数据是分开存储的，而InnoDB是索引和数据是一起以idb文件的形式进行存储的。
- 访问速度：聚簇索引比非聚簇索引快。非聚簇索引需要先查询一遍索引文件，得到索引，跟据索引获取数据。而聚簇索引的索引树的叶子节点的直接指向要查找的数据行

### （8）覆盖索引

**解决列的数据查询**

`select`的数据列只用从索引中就能够取得，不需要**回表**进行二次查询，也就是说查询列要被所使用的索引覆盖。

对于`innodb`表的二级索引，如果索引能覆盖到查询的列，那么就可以避免对主键索引的二次查询。

不是所有类型的索引都可以成为覆盖索引。覆盖索引要存储索引列的值，而哈希索引、全文索引不存储索引列的值，所以MySQL使用b+树索引做覆盖索引。

**如何实现覆盖索引**

将被查询的字段，建立到联合索引里去。组合索引（id,age）

对于使用了覆盖索引的查询，在查询前面使用`explain`，输出的extra列会显示为`using index`。

1、如实现：select id,age from user where age = 10;
explain分析：因为age是普通索引，使用到了age索引，通过一次扫描B+树即可查询到相应的结果，这样就实现了覆盖索引

2、实现：select id,age,name from user where age = 10;
explain分析：age是普通索引，但name列不在索引树上，所以通过age索引在查询到id和age的值后，需要进行回表再查询name的值。此时的Extra列的NULL表示进行了回表查询

### （1）概念

存储引擎是数据库系统中**负责数据存储和检索的模块**，它负责**将数据以特定的方式存储在磁盘**上，**提供了对数据的读取、写入和管理功能。**（保存数据的核心技术）

### （2）常见的存储引擎

MySQL中常用的四种存储引擎分别是： **MyISAM**、**InnoDB**、**MEMORY**、**ARCHIVE**。MySQL 5.5版本后默认的存储引擎为`InnoDB`。

#### 2.1.**InnoDB存储引擎**

InnoDB是MySQL**默认的事务型存储引擎**，使用最广泛，基于聚簇索引建立的。InnoDB内部做了很多优化，如能够自动在内存中创建自适应hash索引，以加速读操作。**B-Tree 索引**是 InnoDB 引擎的默认索引。

**优点**：支持事务和崩溃修复能力；引入了**行级锁和外键约束**。

**缺点**：占用的数据空间相对较大。

**适用场景**：需要事务支持，并且有**较高的并发读写频率**。

#### 2.2. MyISAM存储引擎

数据以紧密格式存储。对于**只读数据，或者表比较小、可以容忍修复操作**，可以使用MyISAM引擎。**MyISAM会将表存储在两个文件中，数据文件`.MYD`和索引文件`.MYI**`。

**优点**：访问速度快。

**缺点**：MyISAM不支持事务和行级锁，不支持崩溃后的安全恢复，也不支持外键。

**适用场景**：对事务完整性没有要求；表的数据都会只读的。

#### 2.3. **MEMORY存储引擎**

MEMORY引擎将**数据全部放在内存**中，访问速度较快，但是**一旦系统奔溃的话，数据都会丢失**。

MEMORY**引擎默认使用哈希索引**，将键的哈希值和指向数据行的指针保存在哈希索引中。

**优点**：访问速度较快。

**缺点**：

1. 哈希索引数据不是按照索引值顺序存储，无法用于排序。
2. 不支持部分索引匹配查找，因为哈希索引是使用索引列的全部内容来计算哈希值的。
3. 只支持等值比较，不支持范围查询。
4. 当出现哈希冲突时，存储引擎需要遍历链表中所有的行指针，逐行进行比较，直到找到符合条件的行。

#### 2.4.**ARCHIVE存储引擎**

ARCHIVE存储引擎非常适合**存储大量独立的、作为历史记录的数据**。ARCHIVE提供了**压缩**功能，拥有**高效的插入**速度，但是这种引擎不支持索引，所以查询性能较差。

### （3）MyISAM和InnoDB的区别？

- **存储结构的区别**。每个MyISAM在磁盘上存储成三个文件。文件的名字以表的名字开始，扩展名指出文件类型。 .frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。InnoDB所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。

- **存储空间的区别**。MyISAM支持支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。当表在创建之后并导入数据之后，不会再进行修改操作，可以使用压缩表，极大的减少磁盘的空间占用。InnoDB需要更多的内存和存储**，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。**

- **可移植性、备份及恢复**。MyISAM数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。对于InnoDB，可行的方案是拷贝数据文件、备份 binlog，或者用mysqldump，在数据量达到几十G的时候就相对麻烦了。

- **是否支持行级锁**。MyISAM 只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。而InnoDB 支持行级锁和表级锁，默认为行级锁。行锁大幅度提高了多用户并发操作的性能。

- **是否支持事务和崩溃后的安全恢复**。 MyISAM 不提供事务支持。而InnoDB 提供事务支持，具有事务、回滚和崩溃修复能力。

- **是否支持外键**。MyISAM不支持，而InnoDB支持。

- **是否支持MVCC**。MyISAM不支持，InnoDB支持。应对高并发事务，MVCC比单纯的加锁更高效。

- **是否支持聚集索引**。MyISAM不支持聚集索引，InnoDB支持聚集索引。

- **全文索引**。MyISAM支持 FULLTEXT类型的全文索引。InnoDB不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。

- **表主键**。MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址。对于InnoDB，如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)。

- **表的行数**。MyISAM保存有表的总行数，如果`select count(*) from table`;会直接取出该值。InnoDB没有保存表的总行数，如果使用select count(*) from table；就会遍历整个表，消耗相当大，但是在加了where条件后，MyISAM和InnoDB处理的方式都一样。

  事务、高并发，索引，主键、行数统计、存储空间

来源：牛客网

## 8、事务

### （1）概念

MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！

在 MySQL 中，事务是一组SQL语句的执行，它们被视为一个单独的工作单元。

- 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。
- 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。
- 事务用来管理 **insert、update、delete** 语句

### （2）事务的特征

可以一银行转账为例来理解

1. **原子性（Atomicity）：** 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
2. **一致性（Consistency）：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 事务的执行应该使数据库从一个一致的状态转移到另一个一致的状态。数据库的完整性约束应该在事务执行之后得到满足。
3. **隔离性（Isolation）：** 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。



1. **持久性（Durability）：** 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

### （3）事务控制语句

- **BEGIN 或 START TRANSACTION** ：显式地**开启一个事务**；

- **COMMIT 也可以使用 COMMIT WORK**：COMMIT 会**提交事务**，并使已对数据库进行的所有**修改成为永久性**的；

- **ROLLBACK 也可以使用 ROLLBACK WORK**：回滚会**结束用户的事务**，**并撤销正在进行的所有未提交的修改**；

- **SAVEPOINT identifier，SAVEPOINT**： 允许**在事务中创建一个保存点**，一个事务中可以有多个 SAVEPOINT；

- **RELEASE SAVEPOINT identifier** ：**删除一个事务的保存点**，当没有指定的保存点时，执行该语句会抛出一个异常；

- **ROLLBACK TO identifier** ：把**事务回滚到标记点**；

- **SET TRANSACTION** ：用来**设置事务的隔离级别**。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。

  **MySQL 事务的例子**

  ```mysql
  -- 开始事务
  START TRANSACTION;
  
  -- 执行一些SQL语句
  UPDATE accounts SET balance = balance - 100 WHERE user_id = 1;
  UPDATE accounts SET balance = balance + 100 WHERE user_id = 2;
  
  -- 判断是否要提交还是回滚
  IF (条件) THEN
      COMMIT; -- 提交事务
  ELSE
      ROLLBACK; -- 回滚事务
  END IF;
  ```

### （4）事务隔离级别

**1. 脏读、不可重复读、幻读**

- **脏读**：脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。
- **不可重复读**：对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据**更新（UPDATE）**操作。
- **幻读**：幻读是针对数据**插入（INSERT）**操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。



**2. MySQL数据库为我们提供的四种隔离级别：**

- 从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，**可重复读**是 MySQL 的默认级别。
- 事务隔离其实就是为了解决上面提到的脏读、不可重复读、幻读这几个问题，下面展示了 4 种隔离级别对这三个问题的解决程度。

![img](https://pic4.zhimg.com/80/v2-2e1a7203478165890e2d09f36cb39857_720w.webp)

**1）Serializable** (串行化)

通过强**制事务排序**，使之不可能相互冲突，从而解决幻读问题。串行化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，**它将事务的执行变为顺序执行**，与其他三个隔离级别相比，它就相当于**单线程**，后一个事务的执行必须等待前一个事务结束。

**2）Repeatable read** (可重复读)

MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，解决了不可重复读的问题。

![1701937885279](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\1701937885279.png)

**3）Read committed** (读已提交)

一个事务只能看见已经提交事务所做的改变。可避免脏读的发生。

读提交事务隔离级别是大多数流行数据库的默认事务隔离界别，比如 Oracle

每个 select 语句都有自己的一份快照，而不是一个事务一份，所以**在不同的时刻，查询出来的数据可能是不一致的**。读提交解决了脏读的问题，但是无法做到可重复读，也没办法解决幻读。

![img](https://pic1.zhimg.com/v2-90289243339a900aaf3f87d9c9930258_r.jpg)

**4）Read uncommitted** (读未提交)

任何事务对数据的修改都会第一时间暴露给其他事务，即使事务还没有提交。（MySQL 事务隔离其实是依靠锁来实现的，加锁自然会带来性能的损失。而读未提交隔离级别是不加锁的，所以它的性能是最好的，没有加锁、解锁带来的性能开销）

![img](https://pic4.zhimg.com/v2-77225da0805e43183c076c24f270e75b_r.jpg)



**3. 修改隔离级别的语句**

```mysql
SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}
```

其中作用域可以是 SESSION 或者 GLOBAL，GLOBAL 是全局的，而 SESSION 只针对当前回话窗口。

**查看隔离级别：**

```mysql
select @@transaction_isolation;
```

### （5）**MySQL 中是如何实现事务隔离的**

### （6）生产环境数据库一般用的什么隔离级别呢？

**生产环境大多使用可重复读**(RC)。为什么不是读已提交(RR)呢？

缘由一：在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多！ 

缘由二：在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行!也就是说，RC的并发性高于RR。并且大部分场景下，不可重复读问题是可以接受的。毕竟数据都已经提交了，读出来本身就没有太大问题！

## 9、MySQL中的锁机制

### （1）概念和作用

​	**锁是计算机协调多个进程或线程并发访问某一个资源的机制**

在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所在有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

### （2）分类

**按锁粒度分类**，有行级锁、表级锁和页级锁。

1. **行级锁**是mysql中锁定粒度最细的一种锁。表示**只针对当前操作的行进行加锁**。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但加锁的开销也最大。行级锁的类型主要有三类：

- Record Lock，记录锁，也就是**仅仅把一条记录锁**上；
- Gap Lock，间隙锁，**锁定一个范围**，但是不包含记录本身；
- Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

2. **表级锁**是mysql中锁定粒度最大的一种锁，表示**对当前操作的整张表加锁**，它实现简单，资源消耗较少，**被大部分mysql引擎支持**。最常使用的**MyISAM与InnoDB都支持表级锁定**。

3. **页级锁**是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。因此，采取了折衷的页级锁，**一次锁定相邻的一组记录**。

**按锁级别分类**，有共享锁(读取数据时)、排他锁（写改数据时）和意向锁。

4. **共享锁**又称读锁，是**读取操作创建的锁**。其他用户**可以并发读取数据，但任何事务都不能对数据进行修改**（获取数据上的排他锁），直到已释放所有共享锁。

5. **排他锁**又称写锁、独占锁，**如果事务T对数据A加上排他锁后，则其他事务不能再对A加任何类型的封锁**。**获准排他锁的事务既能读数据，又能修改数据。**

6. **意向锁**是表级锁，其设计目的主要是为了在一个事务中揭示下一行将要被请求锁的类型。

### （3）实际应用注意事项

1. 意向锁是 InnoDB 自动加的，不需要用户干预。
2. 对于INSERT、UPDATE和DELETE，**InnoDB 会自动给涉及的数据加排他锁**
3. 对于**一般的SELECT语句，InnoDB 不会加任何锁**，事务可以通过以下语句**显式加共享锁或排他锁。**

共享锁：`SELECT … LOCK IN SHARE MODE;`

排他锁：`SELECT … FOR UPDATE;`

## 10、SQL语法

### （1）MySQL中int(10)和char(10)的区别？　

int(10)中的10表示的是显示数据的长度，而char(10)表示的是存储数据的长度。

### （2）truncate、delete与drop区别？

- drop直接删掉表。
- truncate删除表中数据，再插入时自增长id又从1开始。
- delete删除表中数据，可以加where字句。

### （3）exist和in的区别？

**exists**

`exists`指定一个子查询，检测行的存在。遍历循环外表，然后看外表中的记录有没有和内表的数据一样的。匹配上就将结果放入结果集中。

执行流程:首先，我们先查询的不是子查询的内容，而是查我们的主查询的表;然后，根据表的每一条记录，执行括号里面语句，依次去判断where后面的条件是否成立：

```mysql
select * from 'user' where exists(select 'order'.user_id from 'order' 
                                  where 'user'.id = 'order'.user_id )
```

**in**

`in`确定给定的值是否与子查询或列表中的值相匹配。in在查询的时候，首先查询子查询的表，然后将内表和外表做一个笛卡尔积，然后按照条件进行筛选。所以相对内表比较小的时候，in的速度较快。

```mysql
select * from 'user' where 'user'.id in(select 'order'.user_id from 'order')
```

**区别及应用场景**

- **如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用in, 反之如果外层的主查询记录较少，子查询中的表大，又有索引时使用exists。**其实我们区分in和exists主要是造成了驱动顺序的改变(这是性能变化的关键)，如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询，所以我们会以驱动表的快速返回为目标，那么就会考虑到索引及结果集的关系了 ，另外IN时不对NULL进行处理。
- in 是把外表和内表作hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。一直以来认为exists比in效率高的说法是不准确的。

### （4）MySQL查询 limit 1000,10 和limit 10 速度一样快吗？

以主键索引的limit执行过程为例：

```mysql
select * from xxx order by id limit 0, 10;
```

server层会调用innodb的接口，在innodb里的主键索引中获取到第0到10条**完整行数据**，依次返回给server层，并放到server层的结果集中，返回给客户端。

```mysql
select * from xxx order by id limit 500000, 10;
```

  server层会调用innodb的接口，由于这次的offset=500000，会在innodb里的主键索引中获取到第0到（500000 + 10）条**完整行数据**，**返回给server层之后根据offset的值挨个抛弃，最后只留下最后面的size条**，也就是10条数据，放到server层的结果集中，返回给客户端。

**mysql查询中 limit 1000,10 会比 limit 10 更慢。原因是 limit 1000,10 会取出1000+10条数据，并抛弃前1000条，这部分耗时更大。**

### （5）说说count(1)、count(*)和count(字段名)的区别

### （6）MySQL中DATETIME 和 TIMESTAMP有什么区别？

### （7）什么是 内连接、外连接、交叉连接、笛卡尔积等?

- 内连接: 只连接**匹配的行**。

- 左外连接: 包含**左边表的全部行**（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行。

- 右外连接: 包含**右边表的全部行**（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行。

- 全外连接: **包含左、右两个表的全部行**，不管另外一边的表中是否存在与它们匹配的行。

- 交叉连接: 生成笛卡尔积－**它不使用任何匹配或者选取条件**，**而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配**。

  ![img](https://www.runoob.com/wp-content/uploads/2019/01/sql-join.png)

### （8）varchar和char的区别？

- char的长度是不可变的，而varchar的长度是可变的。
- char的存取速度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找。
- char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。

### （9）说说like % - 的区别

### （10）having和where区别？

- 在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。HAVING 子句可以让我们筛选分组后的各组数据。

- 二者作用的对象不同，`where`子句作用于表和视图，`having`作用于组。
- `where`**在数据分组前进行过滤**，`having`**在数据分组后进行过滤**。

```mysql
SELECT column1, aggregate_function(column2)
FROM table_name
GROUP BY column1
HAVING condition;
```

### （11）SQL查询关键字语法顺序和执行顺序

**Mysql语法顺序**

```mysql
select[distinct]  
from  
join（如left join）  
on  
where  
group by  
having  
union  
order by  
limit  
```

**Mysql执行顺序**

```mysql
from  
on  
join  
where  
group by  
having  
select  
distinct  
union  
order by
limit
```

select那里就查询完了，后面的都是对查询的结果的操作（去重、合并排序，结果显示限制）

## 11、分区分表

当单表的数据量达到1000W或100G以后，优化索引、添加从库等可能对数据库性能提升效果不明显，此时就要考虑对其进行切分了。切分的目的就在于减少数据库的负担，缩短查询的时间。

就是把原来的表按某种策略分成多个表，这样查询的时候先定位表在到表里面查询

数据切分可以分为两种方式：垂直划分（列分）和水平划分（行分）。

### （1）**垂直划分**

 垂直划分数据库是根据业务进行划分.

例如购物场景，可以将库中涉及商品、订单、用户的表分别划分出成一个库，通过降低单库的大小来提高性能。同样的，分表的情况就是将一个大表根据业务功能拆分成一个个子表，例如商品基本信息和商品描述，商品基本信息一般会展示在商品列表，商品描述在商品详情页，可以将商品基本信息和商品描述拆分成两张表。

**优点**：行记录变小，数据页可以存放更多记录，在查询时减少I/O次数。

**缺点**：

- **主键出现冗余**，需要管理冗余列；
- **会引起****表连接JOIN操作**，可以通过在业务服务器上进行join来减少数据库压力；
- 依然存在**单表数据量过大**的问题。

### （2）**水平划分**

水平划分是根据一定规则，例如时**间或id序列值等进行数据的拆分**。比如根据年份来拆分不同的数据库。每个数据库结构一致，但是数据得以拆分，从而提升性能。

**优点**：单库（表）的数据量得以减少，提高性能；切分出的表结构相同，程序改动较少。

**缺点**：

- 分片事务一致性难以解决
- 跨节点`join`性能差，逻辑复杂
- 数据分片在扩容时需要迁移

### （3）**分区表**

分区是把一张表的数据分成N多个区块。分区表是一个独立的逻辑表，但是底层由多个物理子表组成。

当查询条件的数据分布在某一个分区的时候，查询引擎只会去某一个分区查询，而不是遍历整个表。在管理层面，如果需要删除某一个分区的数据，只需要删除对应的分区即可。

分区一般都是放在单机里的，用的比较多的是时间范围分区，方便归档。只不过分库分表需要代码实现，分区则是mysql内部实现。分库分表和分区并不冲突，可以结合使用。

## 12、关系型数据库和非关系型数据库

### **（1）关系型数据库**

![img](https://bbs-img.huaweicloud.com/data/forums/attachment/forum/20224/8/1649402276696657846.png)

**关系型数据库的优点**

- 容易理解：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解
- 使用方便：通用的SQL语言使得操作关系型数据库非常方便
- 易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率

**关系型数据库的缺点**

- 网站的用户并发性非常高，往往达到每秒上万次读写请求，对于传统关系型数据库来说，**硬盘I/O是一个很大的瓶颈**
- 网站每天产生的数据量是巨大的，对于关系型数据库来说，在一张包含**海量数据的表中查询，效率非常低**
- **在基于web的结构当中，数据库是最难进行横向扩展**的，当一个应用系统的用户量和访问量与日俱增的时候，数据库却没有办法像web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。**当需要对数据库系统进行升级和扩展时，往往需要停机维护和数据迁移**。
- 性能欠佳：在关系型数据库中，导致性能欠佳的最主要原因是**多表的关联查询**，以及复杂的数据分析类型的复杂SQL报表查询。为了保证数据库的ACID特性，必须尽量按照其要求的范式进行设计，关系型数据库中的表都是存储一个格式化的数据结构。

**无法应对高并发的读写请求、海量数据存储和查询**，较适合银行系统

### **（2）非关系型数据库**

![img](https://bbs-img.huaweicloud.com/data/forums/attachment/forum/20224/8/1649402548064923256.png)

**非关系型数据库的优点**

- 用户可以根据需要去添加自己需要的字段，为了获取用户的不同信息，不像关系型数据库中，要对多表进行关联查询。仅需要根据id取出相应的value就可以完成查询
- 适用于SNS(Social Networking Services)中，例如facebook，微博。系统的升级，功能的增加，往往意味着数据结构巨大变动，这一点关系型数据库难以应付，需要新的结构化数据存储。由于不可能用一种数据结构化存储应付所有的新的需求，因此，非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合

**非关系型数据库的缺点**

- **只适合存储一些较为简单的数据**，对于需要进行较复杂查询的数据，关系型数据库显的更为合适。不适合持久存储海量数据

**非关系型数据库的分类**

![img](https://bbs-img.huaweicloud.com/data/forums/attachment/forum/20224/8/1649402667907122459.png)

### （3）关系型数据库VS非关系型数据库

- **Nosql数据库简单易部署，基本都是开源软件**，不需要像使用Oracle那样花费大量成本购买使用，相比关系型数据库**价格便宜**。
- **查询速度**：Nosql数据库将数据存储于**缓存**之中，而且不需要经过SQL层的解析，关系型数据库将数据存储在**硬盘**中，自然查询速度远不及Nosql数据库。
- **存储数据的格式**：**Nosql**的存储格式是key,value形式、文档形式、图片形式等等，所以**可以存储基础类型以及对象或者是集合等各种格式**，而**数据库则只支持基础类型**。
- **扩展性**：关系型数据库有类似join这样的**多表查询机制**的限制导致**扩展很艰难**。Nosql**基于键值对**，数据之间没有耦合性，所以**非常容易水平扩展**。
- **持久存储**：Nosql不使用于持久存储，海量数据的持久存储，还是需要关系型数据库
- **数据一致性**：非关系型数据库一般强调的是数据最终一致性，不像关系型数据库一样强调数据的强一致性，从非关系型数据库中读到的有可能还是处于一个中间态的数据，**非关系型Nosql不提供对事务的处理**。

## 13、MVCC 

MVCC(`Multiversion concurrency control`) 就是同一份数据保留多版本的一种方式，进而实现并发控制。在查询的时候，通过`read view`和版本链找到对应版本的数据。

作用：提升并发性能。对于高并发场景，MVCC比行级锁开销更小。

## 14、MySQL架构

MySQL主要分为 Server 层和存储引擎层：

- **Server 层**：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。
- **存储引擎**： 主要负责数据的存储和读取。**server 层通过api与存储引擎**进行通信。

**Server 层基本组件**

- **连接器：** 当客户端连接 MySQL 时，server层会对其进行身份认证和权限校验。
- **查询缓存:** 执行查询语句的时候，会先查询缓存，先校验这个 sql 是否执行过，如果有缓存这个 sql，就会直接返回给客户端，如果没有命中，就会执行后续的操作。
- **分析器:** 没有命中缓存的话，SQL 语句就会经过分析器，主要分为两步，词法分析和语法分析，先看 SQL 语句要做什么，再检查 SQL 语句语法是否正确。
- **优化器：** 优化器对查询进行优化，包括重写查询、决定表的读写顺序以及选择合适的索引等，生成执行计划。
- **执行器：** 首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会根据执行计划去调用引擎的接口，返回结果。

## 15、MySQL优化之超大分页查询

```mysql
select * from t5 order by text limit 1000000, 10;
```

**1、使用覆盖索引**

```mysql
explain select * from t5 order by text limit 1000000, 10;
```

**2、子查询优化**

在实际开发中，用SELECT查询一两列操作是非常少的，因此上述的覆盖索引的适用范围就比较有限。

可以通过把分页的SQL语句改写成子查询的方法获得性能上的提升。

```mysql
select * from t5 where id>=(select id from t5 order by text limit 1000000, 1) limit 10;
```

但是这种优化方法也有局限性：

1. 这种写法，要求主键ID必须是连续的
2. Where子句不允许再添加其他条件

**3、延迟关联**

和上述的子查询做法类似，我们可以使用JOIN，先在索引列上完成分页操作，然后再回表获取所需要的列。

```mysql
select a.* from t5 a inner join (select id from t5 order by text limit 1000000, 10) b on a.id=b.id;
```

**4、记录上次查询结束的位置**

和上面使用的方法都不同，记录上次结束位置优化思路是**使用某种变量记录上一次数据的位置**，下次分页时直接从这个变量的位置开始扫描，从而避免MySQL扫描大量的数据再抛弃的操作。

```sql
select * from t5 where id>=1000000 limit 10;
```

其中1000000用一个变量存储，每次下一页，就X++